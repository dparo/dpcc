% You should not modify anything from here ... -------------
\documentclass[a4paper]{article}
\usepackage[english]{babel}
\usepackage{microtype,etex,listings,color,parskip,hyperref}
\usepackage[margin=2cm]{geometry}
\usepackage{hyperref}


\lstset{
    language=C,
    tabsize=2,
    showstringspaces=false,
    breaklines=true,
    basicstyle=\ttfamily,
    keywordstyle=\color[rgb]{0.1,0.3,0.7}\ttfamily,
    stringstyle=\color[rgb]{0.7,0.1,0.3}\ttfamily,
    commentstyle=\color[rgb]{0.3,0.4,0.3}\ttfamily,
    columns=fixed,
    numberstyle=\sffamily\scriptsize,
    backgroundcolor=\color[rgb]{0.95,0.95,0.95},
    frame=lines,
    framexleftmargin=5pt,
    numbers = left,
    numberstyle = \footnotesize,
}

\lstdefinelanguage{DPCC}{
    keywords={ print, int, float, bool, var, typeof, new, true, false, catch,
        function, return, null, catch, switch, let, var, if, of, in,
    for, while, do, else, case, break },
    keywordstyle=\color{blue}\bfseries,
    ndkeywords={class, export, boolean, throw, implements, import, this},
    ndkeywordstyle=\color{darkgray}\bfseries,
    identifierstyle=\color{black},
    sensitive=false,
    comment=[l]{//},
    morecomment=[s]{/*}{*/},
    commentstyle=\color[rgb]{0.3,0.4,0.3}\ttfamily,
    stringstyle=\color{red}\ttfamily,
    morestring=[b]',
    morestring=[b]"
}

\lstset{
    language=DPCC,
    extendedchars=true,
    basicstyle=\footnotesize\ttfamily,
    showstringspaces=false,
    showspaces=false,
    numbers=left,
    columns=flexible,
    numberstyle=\tiny,
    numbersep=9pt,
    tabsize=2,
    breaklines=true,
    showtabs=false,
    captionpos=b,
}

\begin{document}
\tableofcontents


\title{DPCC: DParo's Own C-Alike Compiler}
\author{Davide Paro}
\date{December 2020}

\maketitle


\section{Assignment Description}
This project is the implementation of an assignment for a course on \textbf{Compilers}
at the department of Computer Engineering Master Degree Padova (ITA).


The assignment consists in implementing a toy compiler for a toy language.
Mostly we are required to design the frontend side (input, lexing, parsing, type checking) and
simply emitting a very simple theoretical Intermediate Code (3AC)
We are free to design the syntax of this toy language however we like.

The assignment specs out the how the compiler should be composed.
We can in fact distinguish these macro components:

\begin{itemize}
\item \textbf{Input Stage} deals with the input byte stream that composes
    the source of the program.
\item \textbf{Lexer/Scanner} has the purpose of grouping characters (lexical analysis)
    together to compose compunded
    structures (called tokens). For the project assignment we can use \textbf{Flex} to aid in
    the implementation of the scanner.
\item \textbf{Parser} for performing the syntax analysis. It is what defines the look \& fell
    (grammar) of the language. For the project assignment we can use \textbf{Bison} to aid in the
    implementation of an LR parser.
\item \textbf{Intermediate Code Generator}. The ultimate purpose of a compiler is to produce something
    useful. In this project assignment we are not asked to implement a proper backend. Instead,
    we need to emit a 3AC representation of our input program. More in this later.
\end{itemize}

In particular the final Intermediate representation that we need to emit is based on Three Address Code (3AC),
that is, each statement can only have 1 operand at the left hand side of the assignment, and 2 operands at the right hand side
of the assignment, and an operator driving the operation that should be performed.

You can view more about 3AC at the following \href{https://en.wikipedia.org/wiki/Three-address_code}{wikipedia link}.

In practice the emitted 3AC code is on itself a partially valid C program, it's only missing variable
declarations at the top for the temporary variables.


For the specification of the Intermdiate Code that is generated please refer to \hyperref[appendix_a]{appendix A}

So the project requires to produce this kind of 3AC / C hybrid. Control flow is allowed to be implemented
trough the usage of C labels and simple if conditional followed by a goto statement. Inside
the if conditional there can only be a single element composing the expression.

The assignment requires the following features from the programming langugage that we should develop:

\begin{itemize}
    \item Variables declaration, initialization and assignment
    \item Scoping. Variable names are reusable in different scopes. Variable
        shadowing may or may not warn/fail/pass depending on the design choices.
    \item Only 2 types of variables: integers, booleans
    \item Assignment statements, print statements, if statements, and at least 1 loop statement at our liking
    \item Handling of simple mathematical expressions that we can encounter in common programming
        languages: addition, subtraction, multiplication, division, modulo, etc \dots
    \item \textbf{Function definition, function calls, and custom user definable types are not required}
\end{itemize}

\clearpage

\section{DPL and DPCC: A quick peak at the language and at the compiler}

After describing the project assignment, from now on the following sections will describe the proposed language
and the proposed compiler.

\textbf{DPL} and \textbf{DPCC} are respectively the \textbf{name of the implemented language} and the \textbf{name of the implemented compiler}.
They are named after their author.

From now on \textbf{DPL} and \textbf{DPCC} will be used for brevity for refering to the language and to the compiler


\subsection{DPL: Structure of the language}

The proposed language is very similar to a C and JavaScript Hybrid. Most of the syntax is derived
from C-alike lannguage, and some keyword concepts are instead taken from Javascript. That is newlines
and spaces mostly do not matter, they simply introduce token boundaries.

\begin{lstlisting}[language=DPCC]
// C style Multi-line comments like /* ... */  pair are not supported

// Print statement with immediate C-style strings. C-style strings are not
// a valid type and can only be passed to print
print("Hello world\n");

// Variable declaration and initialization
let a = 10;          // Integer Type deduced
let f = 10.0;        // Float type deduced
let b = false;       // Boolean type deduced

// Explicit types
let i: int = 0xffff & ~0xb00111;
let f: float = 10.0 + 20.0 ** 2;

// Variables can be printed
print(i);       // Print integer
print(f);       // Print float

// Casting can be used to enforce type conversion
let myInt: int = int(10.00f);
let myFloat = float(0xFF);

// Type deduction
let b = (10 < 20);   // Boolean type is deduced
let f = 1 + 2.0f;    // Float type is deduced (the 1 is upcasted to a float)

// Scoping and restricting variable declarations to the current scope
{
    // Simple single dimension arrays declaration
    let buf_i: int[100];            // Known size integer array
    let buf_f: float[100];          // Known size float array

    // Integer array with deduced size from the RHS initializer list
    let buf = [ 10, 20, 30, 40, 50 ];

    // Arrays can be printed
    print(buf);
}

let buf: int[100];

// Control flow
for (let i = 0; i < 100; i++) {
    buf[i] = i ** 2;

    if (buf[i] == 10) {
        print("buf[i] is 10!!!\n")
    }
    else if (buf[i] == 20) {
        print("buf[i] is 20!!!\n");
    }
    else {
        print("None of above\n");
    }
}
\end{lstlisting}


So as the reader can see from above there's not much fancy stuff about the syntax, it is mostly
C-alike. The cool thing though about this implementation is that we can mostly declare variables
with a simple `let` keyword like in Javascript, but unlike Javascript the compiler has a way
to deduce types whenever possible and still provides strong type semantics to each indentifier
like in C (or any other strongly typed language).

For now only 5 types are implemented: \textbf{bool, int, float, string, bool[], int[], float[]}.
Only single dimensions array are for now supported. So arrays do not generalize to any number of dimensions.

Most of these types have full on semantics, meaning that the compiler can deduce
a type of an expression given the types of its operand. In some cases it can reject
the code if the operands of an expression have invalid types.

At the current time of writing this report, \textbf{string} types are quirky, meaning that
they don't have a full type tracking inside
the compiler like other types do.
The compiler still knows what a string is, and in fact a string literal is marked
with the \textbf{string} type, but strings undergo different semantics.
They cannot be assigned or operated on like a variable, but instead,
they can only be used as a parameter to the print statement.


\subsection{DPCC: Using the compiler}
This section shows an high level of an user calling a built compiler to run and or test


\section{The proposed implementation}
In the following sections it is described how the proposed
\begin{itemize}
\item \textbf{Input Stage}. The compiler only supports file. The input stream is implemented
    in the following way. The file is loaded and entirely copied into a memory buffer. This is more
    than adequate for what it's necessary to do for the project assignment.
\item Un \textbf{Lexer/Scanner} per la tokenizzazione del sorgente da caratteri a tipi di dati strutturati. La scelta ricade su \textbf{Flex} per la gestione dell'analisi lessicale
\item Un \textbf{Parser} per implementare la sintassi del linguaggio e gestire l'analisi sintattica. La scelta ricade su \textbf{Bison} per la gestione di questa componente
\item Un semplice \textbf{generator di codice intermedio}. Il progetto provede di generare un ibrido Assembly/C/3AC come semplice esempio di gestione di generazione
\end{itemize}




\section{Implementation Details}
\subsection{Custom log is implemented to override default bison behaviour}

\subsection{Common types used withing the compiler}


\subsection{Most notable functions used in the compiler}

\subsection{How the AST is traversed}

\subsection{How type checking and type deduction is implemented}

\subsection{A brief introduction at the code implementing the compiler}

\begin{itemize}
    \item The order of the childs in each node \textbf{is very important} and it drives
        the correctness of the final output. In this way we can use simple printf to generate
        the code each time we find something while traversing the tree
\end{itemize}

\subsection{Typescript used for code generation of some part of the compiler}

\subsection{Encountered problems}

\subsection{Testing framework}


\section{Problem analysis}

...

\section{Program design}

...

\section{Evaluation of the program}

...

% \section{Evaluation of the program} % Optional
%
% ...

\section{Process description}

...

\section{Conclusions}

...

\section{Appendix A: Structure of the Intermediate Code}
\label{appendix_a}

\section{Appendix: program text}

% Here you should include the program text.
% Do NOT use screenshots or similar methods.
% Below you can see how to use \lstinputlisting{}.



\begin{lstlisting}[language=DPCC]
let a: int[] = 10;
let s = "Hello world";
{

}
\end{lstlisting}

\begin{lstlisting}[language=C]
int main() {

}
char **argv;
\end{lstlisting}


\clearpage
\section{Appendix B: Example Program Iterative Merge Sort}
\label{appendix_b}

\begin{lstlisting}[language=DPCC]
let array = [
    15, 59, 61, 75, 12, 71,  5, 35, 44,
    6, 98, 17, 81, 56, 53, 31, 20, 11,
    45, 80,  8, 34, 71, 83, 64, 28,  3,
    88, 50, 48, 80,  5
];


for (let curr_size = 1; curr_size < len; curr_size = 2 * curr_size) {
    for (let left_start = 0; left_start < len - 1; left_start = left_start + 2 * curr_size) {
        let mid = len - 1;

        if ((left_start + curr_size - 1) < len - 1) {
            mid = left_start + curr_size - 1;
        }

        let right_end = len - 1;

        if ((left_start + 2 * curr_size - 1) < len - 1) {
            right_end = left_start + 2 * curr_size - 1;
        }

        {
            let l = left_start;
            let m = mid;
            let r = right_end;
            let n1 = m - l + 1;
            let n2 = r - m;

            let L: int[1024];
            let R: int[1024];

            for (let i = 0; i < n1; i++) {
                L[i] = array[l + i];
            }

            for (let i = 0; i < n2; i++) {
                R[i] = array[m + 1 + i];
            }


            let i = 0;
            let j = 0;
            let k = l;

            while (i < n1 && j < n2) {
                if (L[i] <= R[j]) {
                    array[k++] = L[i++];
                } else {
                    array[k++] = R[j++];
                }
            }

            while (i < n1) {
                array[k++] = L[i++];
            }
            while (j < n2) {
                array[k++] = R[j++];
            }
        }
    }
}

print("Sorted array\n");
print(array);
\end{lstlisting}


% \section{Appendix: test cases} % Optional
%
% ...

% \section{Appendix: Extensions} % Optional
%
% ...

\end{document}
